#include <bits/stdc++.h>
using namespace std;
#include <limits.h>
#define ROW 9
#define COL 10 
int **dist_arr;
//int ROW,COL;

struct Point
{
    int x;
    int y;
};
 
struct queueNode
{
    Point pt;  
    int dist;  
};
 
int isValid(int i,int j)//to include edges
{
	if((i<0)||(j<0)||(i>=ROW)||(j>=COL))
		return 0;
	else
		return 1;
}
 
// These arrays are used to get row and column
// numbers of 4 neighbours of a given cell
int rowNum[] = {-1, 0, 0, 1};
int colNum[] = {0, -1, 1, 0};
 
// function to find the shortest path between
// a given source cell to a destination cell.
int path(int mat[ROW][COL],  Point start, Point Final)
{
    // check source and finalination cell
    // of the matrix have value 1
    if (!mat[start.x][start.y] || !mat[Final.x][Final.y])
        return INT_MAX;
 
    bool arr_visit[ROW][COL];
    memset(arr_visit, false, sizeof arr_visit);
     
    arr_visit[start.x][start.y] = true;
 
    queue<queueNode> q;
     
    queueNode s = {start, 0};
    q.push(s);  // Enqueue source cell
 
    // Do a BFS starting from source cell
    while (!q.empty())
    {
        queueNode curr = q.front();
        Point pt = curr.pt;
 
        // If we have reached the destination cell, we are done
        if (pt.x == Final.x && pt.y == Final.y)
            return curr.dist;
 
        // Otherwise dequeue the front cell in the queue and enqueue its adjacent cells
        q.pop();
 
        for (int i = 0; i < 4; i++)
        {
            int row = pt.x + rowNum[i];
            int col = pt.y + colNum[i];
             
            // if adjacent cell is valid, has path and
            // not arr_visit yet, enqueue it.
            if (isValid(row, col) && mat[row][col] && !arr_visit[row][col])
            {
                // mark cell as arr_visit and enqueue it
                arr_visit[row][col] = true;
                queueNode Adjcell = { {row, col},
                                      curr.dist + 1 };
                q.push(Adjcell);
                dist_arr[row][col] = curr.dist +1;
            }
        }
    }
 
    //return -1 if destination cannot be reached
    return INT_MAX;
}
 
// Driver program to test above function
int main()
{
    //scanf("%d",&ROW);
    //scanf("%d",&COL);

    //int mat[ROW][COL];

    dist_arr  = (int **)malloc(sizeof(int *) * ROW);//source
    dist_arr[0] = (int *)malloc(sizeof(int) * COL * ROW);//this dynamic decleration copied from http://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/
    for(int i = 0; i < ROW; i++)
        dist_arr[i] = (*dist_arr + COL * i);

    
    for(int i=0;i<ROW;i++)
    for(int j=0;j<COL;j++)
    dist_arr[i][j]=INT_MAX;
    dist_arr[0][0] = 0;

    /*for(int i=0;i<ROW;i++)
    for(int j=0;j<COL;j++)
    scanf("%d", &mat[i][j]);*/

    int mat[ROW][COL] =
    {
        { 1, 0, 1, 1, 1, 1, 0, 1, 1, 1 },
        { 1, 0, 1, 0, 1, 1, 1, 0, 1, 1 },
        { 1, 1, 1, 0, 1, 1, 0, 1, 0, 1 },
        { 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 1, 1, 1, 0, 1, 0 },
        { 1, 0, 1, 1, 1, 1, 0, 1, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 1, 1, 1, 1, 0, 1, 1, 1 },
        { 1, 1, 0, 0, 0, 0, 1, 0, 0, 1 }
    };
    int x1,x0,y0,y1,c=0;
    x0=y0=0;
    x1=3;y1=4;
  Point source = {x0, y0};
   Point Final = {x1, y1};
 
    int dist = path(mat, source, Final);
 
    if (dist != INT_MAX)
       c=1;
    
    mat[x1][y1]=10;
    if(c)
    {
    while(x1!=x0 || y1!=y0)
    for(int i=-1;i<=1;i++)
    for(int j=-1;j<=1;j++)
    if(i!=j && i!=(-j)  )
    if(isValid((x1+i), (y1+j)))
    if(dist_arr[x1+i][y1+j]-dist_arr[x1][y1] == -1)
    {x1=x1+i;y1=y1+j; mat[x1][y1]=4;}
    mat[x0][x1]=5;

   /* if(dist_arr[x1-1][y1] == (dist_arr[x1][y1]-1))
    printf("sssssssssssssssss%d\n",dist_arr[x1-1][y1]);*/
    for(int i=0;i<ROW;i++)
    {
        for(int j=0;j<COL;j++)    
        printf("%5d  ",mat[i][j]);

        printf("\n");
    }
    /*for(int i=0;i<ROW;i++)
    {
        for(int j=0;j<COL;j++)    
        printf("%10d  ",dist_arr[i][j]);

        printf("\n");
    }*/
    }
    return 0;
}
